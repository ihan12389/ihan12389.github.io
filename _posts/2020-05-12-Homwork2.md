---
layout: post
title: FFT 알고리즘
date: 2020-05-12 12:10:10
author: leehan
comments : true
categories : Algorithm
tags : 대학과제, Algotirhm
---

# 목차

#### 1. 푸리에 변환

#### 2. DFT

#### 3. DFT의 특징

#### 4. FFT의 특징



<br/>

# 푸리에 변환

푸리에 변환이란 하나의 신호를 복소 지수 함수들의 합으로 표현하겠다는 것입니다. FFT는 DFT의 보다 스마트한 해결 방법이고 본질은 DFT를 이해해야 FFT를 이해할 수 있습니다.

DFT란 **(Discrete Fourier Transform)**의 약자로 이산 푸리에 변환입니다. 이름 그대로 이산된 신호의 영역에서 푸리에 변환을 수행한다는 뜻입니다.

시간상의 이산 신호들을 푸리에 변환하면 원래는 이산적이지 않은 연속적인 스펙트럼을 얻게됩니다. 그러나 연속적인 스펙트럼은 저희가 고려할 대상은 아닙니다. 저희의 계산 영역은 무한대에 가까운 연속 영역까지는 포함할 수 없으니까요.

때문에 DFT는 이산 시간 푸리에 변환인 DTFT와는 다릅니다. **샘플링**이라는 개념 때문입니다. 연속된 신호가 있다고 가정합니다. 이 신호를 DTFT해주기 위해서는 샘플링하여 이산 신호로 바꿔줘야 합니다. 그렇게 얻은 시간 영역의 이산 신호들은 DTFT 과정을 거치면 연속된 스펙트럼이 됩니다. 이 연속된 스펙트럼을 샘플링해주면 이산된 스펙트럼을 얻을 수 있습니다.

이 이산된 스펙트럼이 컴퓨터가 처리하기 좋은 형태일 겁니다. 그러나 다시 이 이산된 스펙트럼을 다시 이산된 시간 영역의 신호로 복원하려면 샘플링 시켰던 신호들을 다시 연속 스펙트럼으로 복원하고 역 DTFT를 거치는 과정을 거쳐야 합니다. 이런 번거로움 없이 그저 이산 신호와 이산 스펙트럼에 직접 쌍대성을 연결하는 게 DFT입니다.

먼저 푸리에 변환의 이해를 좀 더 심화해봅시다.

푸리에 변환의 목적은 시간 영역에서 표현되는 신호를 주파수의 영역으로 표현하는 것입니다.

시간 영역에서 하나의 신호는 '시간'이라는 축과 '진폭'이라는 축으로 표현됩니다. 이는 평소 우리에게 가장 익숙한 형태의 표현 그래프입니다.

그러나 주파수 영역의 신호는 '주파수(frequency)'라는 축과 '크기(magnitude)'라는 축으로 표현됩니다.

![](https://mblogthumb-phinf.pstatic.net/MjAxNzA0MDRfMTIw/MDAxNDkxMjk2ODI5OTI3.WNJ2PmUpTSv6vM-TXdD37AwUZBXK-FntxLE27Eeu96cg.al4VI9Fn-cwsrJ1N7ZgiHElTR3vtMav2Qaz59uGruLgg.PNG.specialist0/Capture_2.png?type=w800)

다음의 그래프를 봅시다. 맨 위의 그래프가 시간 영역의 신호고 그 아래가 주파수 영역의 신호입니다.

시간 영역의 신호를 푸리에 변환한 겁니다. 상당히 형태가 다르죠.

시간 영역의 신호는 사각형 형태의 신호를 샘플링한 이산 신호입니다.

그리고 그 푸리에 변환의 결과는 주파수 영역에서 sinc 함수로 나타내어 집니다.

그 sinc 함수를 다시 역변환 하면 시간 영역의 함수로 돌아와 원래의 사각형 신호를 그리는 걸 확인할 수 있습니다.

그러면 왜 주파수 영역으로 신호를 표현하는 번거로운 짓을 하는 걸까요?

그건 주파수 영역에서 신호를 해석하는 게 유리할 때가 있기 때문입니다.

가령 sin(2π)로 표현되는 주기 함수는 시간 영역에선 무한대의 영역을 차지합니다. 주기 함수의 끝은 없으니까요.

그러나 이걸 주파수의 영역으로 푸리에 변환하면 단지 두 개의 선으로 표현됩니다. 다음 처럼요.

![](https://raw.githubusercontent.com/angeloyeo/angeloyeo.github.io/master/pics/negative_frequency/pic1.png)

물론 주파수와 위상을 좀 더 효과적으로 분석할 수 있다는 이점 또한 있습니다.

이 푸리에 변환을 컴퓨터로 쉽게 하기 위한 알고리즘이 DFT입니다. 좀 더 어렵게 말하면 주기적인 N개 유한 시간 샘플 수열에 대해 주기적인 N개 유한 주파수 샘플 계수를 대응시킨 겁니다.

펜을 이용하면 공식으로 함수 자체를 계산할 수 있겠지만 컴퓨터의 계산은 수열을 사용합니다.

모든 신호는 이산적이어하죠. 

그리고 수열을 사용하여 계산을 하기 때문에 입력된 샘플링 개수만큼의 결과값이 도출될 수 밖에 없습니다.

예를들어 32개의 이산된 신호를 넣으면 주파수 영역값도 32개의 이산화된 신호로 리턴될 겁니다.

적분이 아니라 시그마로 계산을 했으니 당연한 결과입니다.

이산 푸리에 변환의 공식은 다음과 같습니다.

![image-20200513005233728](https://ifh.cc/g/iPAS9Y.png)

이 공식을 쉬운 말로 풀이하자면 이산된 신호 하나하나를 일일이 연속된 수열에 대입하여 계산하겠다는 뜻입니다.



위의 DFT 수식을 그대로 코드에 적용하면 32개의 신호를 각각 32개의 수열에 계산하여 32개의 다른 수열을 반환하는 과정을 거치게 되고 단순한 반복문으로 구현했을 경우 for문을 두 번 돌리게 되어 32*32라는 계산횟수가 도출됩니다.

즉, 시간 복잡도로 치면 O(n<sup>2</sup>)인 겁니다.

DFT는 구현이 굉장히 간단합니다.

다만 MATLAB같은 도구를 사용하지 않고 C언어 등으로 구현하려면 복소수의 표현 때문에 상당히 귀찮아지는 것도 사실입니다.

C 언어에 복소수를 표현하고 계산하는 라이브러리가 아예 없는 건 아니지만 그보다 편한건 복소수로 한꺼번에 계산하지 말고 실수부와 허수부로 나누어 따로 계산을 해주는 겁니다.

오일러 정리를 사용하여 복소수를 다음처럼 표현할 수 있습니다.

<img src="https://ifh.cc/g/7JqPo0.png" alt="image-20200513005300317" style="zoom: 80%;" />

아래에는 간단하게 DFT를 C언어로 구현해보도록 하겠습니다.

# DFT

```C++
struct complexNum
{
    float real;
    float imag;
} complexNum;

typedef struct complexNum COMPLEX;
```

복소수를 표현하는 타입을 생성했습니다. 이런 별도의 설정이 없이도 복소수를 표현하는 라이브러리가 이미 있지만 복소수 계산의 가시성을 위해 복소수 구조체를 정의했습니다.

이렇게 실수와 허수부를 표현한 다음에는 DFT할 신호를 입력해주었습니다.

```C++
float origin_signal[N] = {1000,707,0,-707,-1000,-707,0,707};
COMPLEX dft_done[N];
float recover_signal[N];
```

`origin_signal`은 입력된 파형을 샘플링하여 이산 신호로 변환한 입력 신호입니다. `dft_done`은 이산 푸리에 변환 과정을 거친 복소수들을 입력받을 배열입니다. `recover_signal`은 이산 푸리에 역변환을 거친 다시 시간 영역으로 복구된 신호를 저장할 배열입니다.

```C++
void DFT(float *origin_signal,COMPLEX *dft_done)
{
	float num_re,num_im;

	for(int i=0;i<N;i++)
	{
		num_re = 0;
		num_im = 0;
		
		for(int j=0; j<N; j++)
		{
			num_re += origin_signal[j]*cos(2*PI*i*j/N); 
			num_im -= origin_signal[j]*sin(2*PI*i*j/N); 
		}
		
		dft_done[i].real = num_re;
		dft_done[i].imag = num_im;
	}
}
```

이산 푸리에 변환을 수행하는 함수입니다.

가장 간단한 형태로 for문을 총 두 번 돌려서 구현함을 알 수 있습니다. 실수부와 허수부를 나누어 따로 계산하며 보시다시피 오일러 정리를 사용해서 cos와 sin으로 나누었음을 알 수 있습니다.

```C++
void IDFT(COMPLEX *dft_done,float *recover_signal)
{
	float result;

	for(int i=0; i<N; i++)
	{
		result = 0;
		for(int j=0; j<N; j++)
		{
			result += (dft_done[j].real*cos(2*PI*i*j/N) - dft_done[j].imag*sin(2*PI*i*j/N))/N;
		}
		recover_signal[i] = result;
	}
}
```

역변환을 수행한 함수입니다. 

<img src="https://ifh.cc/g/hxKAln.png" alt="image-20200513005332127" style="zoom:80%;" />

공식은 다음과 같습니다. 주의해야할 건 DFT 과정과는 달리 IDFT 과정은 전체 값을 N으로 나눈다는 겁니다. 나누지 않으면 DFT와 IDFT를 거치면서 계속 더하기만 할테니 값이 계속 커져만 갈테고 쌍대성이 성립되지 않을 겁니다.

이러한 공식을 적용하여 전체 코드를 구현하면 다음과 같습니다.

```C++
#include <stdio.h>
#include <math.h>		

#define N 8         //프레임 사이즈  
#define PI 3.141592 //파이 근사 크기
   
struct complexNum{  //복소수 구조 
	float real;     //실수 
	float imag;     //허수 
}complexNum; 

typedef struct complexNum COMPLEX;      //COMPLEX라는 복소수 타입 생성 

void DFT(float *input,COMPLEX *output);  //DFT 함수 정의 
void IDFT(COMPLEX *input,float *output); //IDFT 함수 정의 

int main(int argc,char* argv[])
{
	float origin_signal[N] = {1000,707,0,-707,-1000,-707,0,707};
	COMPLEX dft_done[N];
	float recover_signal[N];

	DFT(origin_signal,dft_done);
	IDFT(dft_done, recover_signal);

	for(int i=0; i<N; i++)
	{
		printf("%d: (%4f, %4f)\n", i, dft_done[i].real, dft_done[i].imag);
	}

	printf("\n\n");

	for(int i=0; i<N; i++)
	{
		printf("%d: (%4f)\n", i, recover_signal[i]);
	}

	return 0;
}

void DFT(float *origin_signal, COMPLEX *dft_done)
{
	float num_re,num_im;

	for(int i=0;i<N;i++)
	{
		num_re = 0;
		num_im = 0;
		
		for(int j=0; j<N; j++)
		{
			num_re += origin_signal[j]*cos(2*PI*i*j/N);
			num_im -= origin_signal[j]*sin(2*PI*i*j/N);
		}
		
		dft_done[i].real = num_re;
		dft_done[i].imag = num_im;
	}
}

void IDFT(COMPLEX *dft_done, float *recover_signal)
{
	float result;

	for(int i=0; i<N; i++)
	{
		result = 0;
		for(int j=0; j<N; j++)
		{
			result += (dft_done[j].real*cos(2*PI*i*j/N) - dft_done[j].imag*sin(2*PI*i*j/N))/N;
		}
		recover_signal[i] = result;
	}
}
```

이 경우 결과값은 다음과 같습니다.

![image-20200513005418351](https://ifh.cc/g/iakXCH.png)

위의 행렬이 DFT를 적용한 행렬이고 아래 행렬은 IDFT를 적용하여 다시 복원한 행렬입니다.

사실 완벽하게 정확한 구현은 아닙니다. 원래 신호로 변환하는 과정에서 미세한 차이가 발생했음을 확인할 수 있습니다.

그러나 근소한 차이를 제외하면 DFT와 IDFT 사이의 성능과 쌍대성이 제대로 구현되고 있다고 할 수 있습니다. 

# DFT의 특징

위의 DFT 코드는 복잡도가 O(n<sup>2</sup>)나 되어서 실질적으로 사용하기엔 무리가 있습니다. 음성 신호의 처리 같은 경우는 64Kbps나 되는 신호를 샘플링하여 변환해야하기도 하는데 저 방식을 적용하면 굉장히 긴 시간이 걸리게 됩니다.

그래서 이를 좀 더 빠르게 처리하기 위한 알고리즘이 FFT(Fast Furier Transform)입니다. 이를 이용해서 O(n<sup>2</sup>)보다 빠르게 DFT를 수행하겠습니다.

어떻게 DFT보다 빠르게 이산 푸리에 변환을 수행할 수 있는지에 대해 이해하려면 먼저 DFT의 특징에 대해서 알아야 합니다.

기본적으로 푸리에 변환 시스템은 종류에 따라 다르긴하지만 고정된 흥미로운 특징들을 가지고 있습니다. 대부분이 푸리에 변환 자체가 보편적으로 가지는 특징들입니다. DFT 또한 마찬가지입니다.

시간 영역의 신호가 이동하면 푸리에 변환의 결과는 이동한 시간에 알맞게 규칙에 따라 변화합니다. 그 반대 또한 마찬가지 입니다. 예를들어 시간 영역의 신호가 n<sub>0</sub>만큼 이동했다면 주파수 영역의 매핑되는 DFT 계수는 크기나 주파수가 변하지는 않고 회전인자(위상)만 변합니다.

<img src="https://ifh.cc/g/IHhi3y.png" alt="image-20200513005451525" style="zoom:80%;" />

역시 주파수 상의 신호를 이동시켜도 시간 영역에서의 신호의 크기는 변하지 않고 회전인자(위상)만 변합니다.

<img src="https://ifh.cc/g/DXANu1.png" alt="image-20200513005506342" style="zoom:80%;" />

이는 굉장히 중요합니다. 이 성질을 이용해서 DFT를 분할 정복할 수 있기 때문입니다.

**쿨리-튜키 알고리즘**은 FFT 알고리즘 중에서 가장 많이 사용되는 알고리즘입니다. 핵심은 수열을 짝수와 홀수로 분해하는 겁니다.

주기가 8인 신호의 DFT를 가정해봅니다.

<br/>

X[k] = x[0]W<sub>N</sub><sup>0</sup> + x[1]W<sub>N</sub><sup>1k</sup> +  x[2]W<sub>N</sub><sup>2k</sup> +  x[3]W<sub>N</sub><sup>3k</sup> + x[4]W<sub>N</sub><sup>4k</sup> + x[5]W<sub>N</sub><sup>5k</sup> + x[6]W<sub>N</sub><sup>6k</sup> + x[7]W<sub>N</sub><sup>7k</sup>

<br/>

W<sub>N</sub><sup>k</sup>는 회전인자로 불리는 복소수이며 exp(2πn/N*ki)입니다. 

위의 수열을 부분 문제로 나누는 방법은 어렵지 않습니다. 홀수와 짝수로 나누어 정리를 해주면 식은 다음과 같은 형태를 가지게 됩니다.

<br/>

X[k] = [x[0]W<sub>N</sub><sup>0</sup> + x[2]W<sub>N</sub><sup>2k</sup> + x[4]W<sub>N</sub><sup>4k</sup> + x[0]W<sub>N</sub><sup>6k</sup>] + w<sub>N</sub><sup>1k</sup>[x[1]W<sub>N</sub><sup>0</sup> + x[3]W<sub>N</sub><sup>2k</sup> + x[5]W<sub>N</sub><sup>4k</sup> + x[7]W<sub>N</sub><sup>6k</sup>]

<br/>

이런 형태로 나눌 수 있습니다.

이는 각각 주기 N/2를 갖는 수열로서 이 각각의 신호들을 DFT 해주면 O(4<sup>2</sup>)+O(4<sup>2</sup>) ... 대략 32 수치이므로 주기 N을 그대로 DFT한 O(8<sup>2</sup>)인 64보다는 작은 수치입니다.

자, 그러면 정리한 식을 아래에 요약해봅시다.

X[n] = X<sub>even</sub>[n] + W<sub>N</sub><sup>n</sup>X<sub>odd</sub>[n] 으로 요약할 수 있을 겁니다.

이는 단순히 생각하면 다음과 같습니다.

![image-20200513005536892](https://ifh.cc/g/YprU0a.png)

f는 X<sub>even</sub>을 g는 X<sub>odd</sub>를 의미합니다.

하지만 여기서 위에서 언급한 주파수 이동성의 특징을 사용할 수 있습니다.

A[4~7]은 A[0~3]보다 N/2 앞으로 이동한 신호라고 봐도 무방합니다.

따라서 다음과 같이 성립할 수 있습니다.

![image-20200513005551884](https://ifh.cc/g/gtvZXb.pnghttps://ifh.cc/g/gtvZXb.png)

여기서 n/2승을 취하면 -1이 되는 점을 이용하여 다음과 같이 계산할 수 있습니다.

![image-20200513005610171](https://ifh.cc/g/InHekW.png)

이게 의미하는 건 결국 주기 N/2으로,

A[n]는 f[n] + W<sub>N</sub><sup>n</sup>g[n]으로 구할 수 있고 A[n+N/2]는 f[n] - W<sub>N</sub><sup>n</sup>g[n]으로 구할 수 있다는 의미가 됩니다. 이는 f[0~7] 혹은 g[0~7]까지 구할 필요가 없다는 걸 의미합니다. 이렇게 주기 N을 주기 N/2로 분할 시켰습니다.

과정을 간략화 시키면 다음과 같습니다. 1. 수열을 주기 N/2를 가진 f와 g로 나눕니다. 2. 각각 주기 N/2를 이용해서 DFT 해줍니다. 3. 각각의 결과를 결합해 원하는 수열의 DFT를 구합니다.

이런 과정을 그림으로 도식화하면 다음과 같습니다.

<img src="https://www.researchgate.net/profile/Caiwen_Ding/publication/321794641/figure/fig1/AS:614082222759950@1523420019485/Illustration-of-Cooley-Tukey-algorithm-of-FFT.png" style="zoom:150%;" />

그러나 이런 과정을 거쳐도 주기 N=8임을 감안할 때 겨우 절반 수준으로 시간복잡도가 감소했습니다. 전체적으로 봤을 때 큰 이득은 없는 셈입니다.

따라서 위에서 설명한 과정을 f[n]와 g[n]에도 적용해줍니다. 쉽게 말하면 주기 N/2를 또 절반인 N/4로 나누는 셈입니다.

이 과정을 계속 적용하면 최종적으로 주기가 2인 DFT를 분해하는 경지까지 올 수 있을 겁니다.

이 역시 그림으로 도식화하면 다음과 같습니다.

![](https://mblogthumb-phinf.pstatic.net/MjAxNzA0MDZfMTcw/MDAxNDkxNDI4MDg5Mzcx.PJUARlZNyr0hQ3oCnDf03f3guOH-1UQNk3lBcfPJi8Ug.XebMs58n9rA3W0TPEaUmhRtKdgBYQakPwXhNUI04G0Mg.PNG.specialist0/Capture_22.png?type=w2)

이러한 과정을 거치게 되면 시간복잡도는 눈에 띄게 줄어들게 됩니다.

위의 그림의 시간 복잡도를 계산하면, 첫번째 단계에서 8번의 계산이 들어가고 두번째 단계에서 4번과 4번 즉 총 8번의 계산이 들어가며 마지막 단계에서 또 8번의 계산이 들어가게 됩니다.

즉, 주기 N이 log<sub>2</sub>N만큼 반복됩니다.

그렇게 되면 시간 복잡도는 O(Nlog<sub>2</sub>N)이며 N=8을 계산할 때 24의 수치가 나옵니다.

아주 획기적인 시간 단축입니다. 그러나 문제는 X[0~N-1]까지는 구하기 위해 x[n]을 짝수와 홀수로 재배치했던 것처럼 수열의 분할을 계속 거치면 입력 수열의 배열이 아주 이상해진다는 것입니다.

그러나 이 문제는 아주 쉽게 해결할 수 있습니다.

수열의 인덱스를 비트로 열거했을 때 비트를 뒤집기만 하면 그게 입력 수열의 재배치 형태가 되기 때문입니다.

**x[n]**......................**X[N]**

000.......................000

100.......................001

010.......................010

110.......................011

001.......................100

101.......................101

011.......................110

111.......................111

이로서 FFT를 구현하기 위한 모든 준비를 마쳤습니다.

다음 장에선 실제로 구현에 들어가도록 하겠습니다.

# FFT

DFT 구현에서 사용했던 코드를 수정하여 FFT를 구현했습니다.

DFT에서는 입력 행렬과 출력 행렬을 따로 설정하였지만 FFT에서는 입력 수열의 재배열과 재귀 함수를 위해서 입력 행렬과 출력 행렬을 같은 공간으로 설정했습니다.

우선 첫번째로 해야할 일은 입력된 행렬의 인덱스를 재배치하는 겁니다.

때문에 공식화처럼 사용되어지고 있는 비트 뒤집기 코드를 가져왔습니다.

```C++
inline unsigned bitreverse(const unsigned n, const unsigned k) 
{
    unsigned r, i;
    for (r = 0, i = 0; i < k; ++i)
        r |= ((n >> i) & 1) << (k - i - 1);
    return r;
}
.
.
.
    const unsigned k = __builtin_ctz(N);
    unsigned s, i, j;
    
	/*재배열*/ 
    for (i = 0; i < N; i++) 
	{
        j = bitreverse(i, k);
        if (i < j)
            swap(origin_signal[i], origin_signal[j]);
    }
```

`__builtin_ctz`는 왼쪽으로 이동할 때 처음 1을 만나기 전까지의 0의 개수를 반환하는 함수입니다.

bitreverse 함수를 통해 재배열 된 인덱스를 얻을 수 있으며 0~N-1까지 반복해서 재배열된 인덱스를 넣으면 결국 원점이기 때문에 재배열된 함수가 원본보다 크다는 가정하에만 서로 위치를 `swap` 시켜줍니다.

```C++
/*푸리에 변환*/
	for(T = 2; T <= N; T *= 2) 
	{
	    COMPLEX W[T/2];
        for (i = 0; i < T/2; i++) 
	    {
	    	if(flag == true) l = -1;
	    	else l = 1;
	    	
            long double t = 2*PI*i/T*l;
            W[i].real = cos(t);
            W[i].imag = sin(t);
        }
        for (i = 0; i < N; i += T) 
        {
            for (j = 0; j < T/2; j++) 
            {
                COMPLEX tmp = mulc(origin_signal[i+j+T/2], W[j]);
                
			    origin_signal[i + j + T/2] = subc(origin_signal[i+j], tmp);
			    origin_signal[i+j] = addc(origin_signal[i+j], tmp);
            }
        }
    }
```

그 후에는 푸리에 변환입니다. 

그림을 참조하여 푸리에 변환의 실행을 설명하겠습니다.

![image-20200513001433233](https://ifh.cc/g/BuQVcX.png)

우선 전체적인 단계는 입력 원소의 log2(N) 개수만큼 실행됩니다. 8개를 샘플링했을 때를 기준으로 하면 전체적인 단계는 3번인셈입니다.

![image-20200513001620152](https://ifh.cc/g/2mzP0u.png)

우선 제일 먼저 주기가 2인 DFT를 수행해야 합니다. 참고로 주기는 2, 4, 8 순(2의 배수)으로 올라갈 겁니다. 이 주기를 변수 T에 설정했습니다.

주기가 설정될 때마다 그 주기에 걸맞는 회전 인자 W를 설정했습니다. 이 역시 복소수 타입인 COMPLEX를 사용하여 cos와 sin으로 나누어 입력했습니다. 그리고 현재 수행하는 푸리에 변환이 역변환인지 정변환인지도 논리 변수 flag로 판단하여 W의 값을 설정했습니다.

이제는 반복문을 돌려 f로부터 A, B, C, D를 계산해내면 됩니다. 그러나 주의해야할 사항이 있습니다. 위의 반복문에서는 f<sub>even</sub> - Wf<sub>odd</sub>에서 (even, odd가 짝수와 홀수를 의미하는 건 아니고 그저 인덱스상의 위치를 의미할 뿐입니다) Wf<sub>odd</sub>를 미리 정의해서 tmp 변수에 저장했습니다. 그리고 f<sub>even</sub>과 tmp를 계산해  A<sub>even, odd</sub>를 구하는 건데 문제는 이 반복문의 입력과 출력은 같은 COMPLEX 공간인 `origin_signal`을 사용하고 있다는 점입니다. 때문에 f<sub>even</sub>를 먼저 계산하면 f<sub>odd</sub>를 계산할 때 f<sub>even</sub> - Wf<sub>odd</sub>의 결과가 엉뚱한 값이 나오게 됩니다. 그러니 f<sub>odd</sub>를 먼저 계산해주고 f<sub>even</sub>을 그 뒤에 계산해줘야 합니다.

![image-20200513002955187](https://ifh.cc/g/np7LpY.jpg)

그 후에는 그저 주기를 두 배씩 늘리며 같은 과정을 반복해줄 뿐입니다. 주기 4로 설정한 W<sub>4</sub><sup>n</sup>를 설정하고 주기가 4인 DFT이니 f<sub>even</sub>과 f<sub>odd</sub>의 인덱스상의 거리도 두 배씩 늘어납니다.

최종적으로 원하는 주기 8인 DFT도 같은 과정을 거쳐 구할 수 있습니다.

![image-20200513003403447](https://ifh.cc/g/p0FguK.jpg)

결과적으론 처음에 재배치했던 인덱스도 제대로 본래의 인덱스대로 배치된 걸 확인할 수 있습니다.

그리고 마지막으로 flag로 정변환인지 역변환인지 확인하여 결과에 N을 나누어주었습니다. 이렇게 하면 간단하게 FFT를 구현할 수 있습니다.

그러나 이러한 알고리즘은 샘플링의 개수가 오로지 2의 n승일 때만 성립합니다. DFT보다 시간 복잡도는 줄였지만 샘플링의 개수에 이러한 제약이 붙었습니다. 이것이 쿨리-튜키 알고리즘의 단점입니다.

# Big O 표기법

이제는 코드를 살펴보며 Big O 표기법의 시간 복잡도를 분석해보도록 하겠습니다.

경우에 따라서 정확한 시간복잡도를 구하는 게 어려울 수 있습니다. 따라서 가장 차수가 높은 것만 남겨놓아 비교하는 Big O 표기법이 있습니다. Big O 표기법은 알고리즘의 성능을 나타낼 때 사용합니다. 그 기준은 다음과 같이 있습니다.

* O(1) Constant Time
* O(logn) Logarithmic
* O(n) Linear
* O(nlogn) Log-Linear
* O(n<sup>2</sup>) Quadratic
* O(n<sup>3</sup>) Cubic
* O(2<sup>n</sup>) Exponential

주로 알고리즘의 최악의 효율, 즉 가장 오래 걸리는 시간의 상한을 나타낼 때 쓰입니다.

이러한 Big O 표기법은 정확한 시간 복잡도를 계산할 때는 사용하면 안된다는 걸 주의해야 합니다. 데이터 양과 시간 복잡도의 상관 관계를 파악하는 정도로 쓰인다는 걸 유의해야 합니다. 즉, 구현한 알고리즘이 정확하게 시간복잡도가 nlogn으로 비례하여 증가하지는 않을 거라는 뜻입니다.

```C++
for(T = 2; T <= N; T *= 2)
```

FFT 변환의 최상위 반복문이 실행되는 구간입니다. 우선 샘플의 개수가 2의 n승이며 최소 샘플 수가 2라는 가정을 붙였습니다. 주기 T는 2씩 곱해져 증가하므로 logN만큼 전체 반복문이 실행됩니다. 따라서 8개의 샘플 데이터 수를 입력했을 때 3번 전체 반복문이 실행되었습니다.

```C++
for (i = 0; i < N; i += T)
    for (j = 0; j < T/2; j++)
        COMPLEX tmp = mulc(origin_signal[i+j+T/2], W[j]);
        
        origin_signal[i + j + T/2] = subc(origin_signal[i+j], tmp);
        origin_signal[i+j] = addc(origin_signal[i+j], tmp);
```

그리고 하위 반복문입니다. 사실 이 부분을 보면 정확한 시간 복잡도가 nlogn에 비례하지 않는다는 걸 알 수 있습니다. 우선 첫번째 for문은 N/T만큼 실행되며 두 번째 하위 반복문은 T/2만큼 실행됩니다. 그리고 반복문 안에는 tmp를 구하는 곱셈 연산과 origin_signal의 <sub>even, odd</sub>를 구하는 연산이 각각 한 번씩 실행되기에 총 3번의 연산이 실행됩니다. 따라서 N/T × T/2 × 3은 3/2×N이므로 전체 시간 복잡도는 Nlog(N)×2/3이 됩니다. 물론 이 또한 옳은 수치는 아닙니다. 곱셈과 덧셈 연산을 수행하는 함수 subc()와 addc()에는 허수부와 실수부 각각 두 개 이상의 연산이 정의되어 있기 때문입니다.

따라서 주목해야하는 부분은 시간복잡도가 어떻게 증가하느냐는 것입니다. 입력 데이터 샘플의 개수가 2일 때와 4일 때 연산의 개수가 정확히 두 배만큼 늘어나는지, 아니면 제곱에 비례하는지를 확인해봐야 합니다.

만약 입력 데이터 샘플의 개수가 2라고 가정하면 전체 반복문은 한 번, 두 번째 반복문도 한 번, 세 번째 반복문도 한 번 실행됩니다. 그러나 입력 데이터 샘플의 개수가 그 두 배인 4번일 때는 전체 반복문은 두 번, 두 번째 반복문도 1, 2회 반복되니 총 4번 실행됩니다.

(N == 4) logN × N/T × T/2 = 12

![](https://ifh.cc/g/aBXDUr.jpg)

샘플링 데이터 개수가 8개일 때는 총 12번 실행됩니다.

![image-20200513193254730](https://ifh.cc/g/hyAh9E.jpg)

위의 계산은 고정된 계산을 제외한 반복문의 증가만 센 것입니다. 시간복잡도의 증가는 입력 데이터를 두배로 늘렸을 때 두배보다는 크지만 제곱과는 비례하지 않는 추이를 보입니다. 즉, logN × N/2 즉, Big O 표기법으로 하면 Olog(nlogn)의 시간복잡도를 가진다고 표현할 수 있습니다.

# 6. 그래프 그리기

x(t) = 3cos(20πt) + 6sin(30πt - 3/(4π))을 FFT로 계산하기 위해서 먼저 입력 파형을 128개의 신호로 샘플링 했습니다. 샘플링 과정은 MATLAB 도구를 사용했습니다.

```
t = [0:0.0078125:1];

for(a = 1:128)
    b = 3*cos(20*pi*t) + 6*sin(30*pi*t - 3/(4*pi));
end
```

정확히는 129개의 행렬 개수가 얻어지지만 처음 신호와 같은 값을 가지는 마지막 신호는 제외했습니다. (0 <= t < 1) 1을 128로 나누면 정확히 나누어 떨어지지만 127로 나누어 떨어지지 않기 때문에 이렇게 했습니다.

이렇게 얻은 신호 행렬을 C++ 언어로 구현한 FFT 코드에 입력했습니다.



```C++
#include <stdio.h>
#include <math.h>	
#include <bits/stdc++.h>

using namespace std;
 
#define N 128 //프레임 사이즈  
#define PI 3.141592 //파이 근사 크기 

/* 컴퓨터는 complex라는 개념이 없습니다
   따라서, real, image를 개념적으로 생각하면서
   변수를 다뤄야 합니다. */
   
struct complexNum{ //복소수 구조 
	float real; //실수 
	float imag;//허수 
} complexNum; 

typedef struct complexNum COMPLEX; //COMPLEX라는 복소수 타입 생성 

void DFT(COMPLEX *input, bool is_reverse); //DFT 함수 정의 
void IDFT(COMPLEX *input,float *output); //IDFT 함수 정의 

COMPLEX mulc(COMPLEX x, COMPLEX y) /*곱하기 연산을 수행하는 함수 선언(결과값은 Complex 구조체형태로 저장)*/
{
	COMPLEX result;
	
	result.real = x.real * y.real - x.imag * y.imag;
	result.imag = x.real * y.imag + x.imag * y.real;
	/*복소수 두 개를 곱하는 연산(a+bi)(c+di) = (ac-db)+i(ad+bc)*/
	
	return result;
}

COMPLEX addc(COMPLEX x, COMPLEX y) /*덧셈 연산을 하는 함수 선언(결과값은 Complex 구조체형태로 저장)*/ 
{
	COMPLEX result;
	
	
	result.real = x.real + y.real;
	result.imag = x.imag + y.imag;
	/*복소수 두 개를 더하는 연산*/
	 return result; 
}

COMPLEX subc(COMPLEX x, COMPLEX y) /*뺄셈 연산을 하는 함수 선언*/ 
{
	COMPLEX result;
	
	result.real = x.real - y.real;
	result.imag = x.imag - y.imag;
	/*복소수 두 개를 뺄셈하는 연산*/
	return result; 
}
 
int main(int argc,char* argv[])
{
	float in[N] = {1.58117290805271, 5.50955748708543,7.32940011177339,5.82180991272128,1.38085804046955,-4.09919489454443,-8.10929252711690,-8.74755257686195,-5.66312539755750,-0.242731343193260,5.05789244596028,7.90304500157578,7.19023078600679,3.53361073999904,-1.11201710181095,-4.47823706511017,-5.12557530312002, -3.11736451276656,0.107228634299666,2.57299254638533,2.86394683579010,0.889660158817946,-2.08214050074099,-4.14020031202558,-3.80770283223834,-0.904357437740698,3.27693358262348,6.59002131306407,7.14266217975586,4.31838746708261,-0.826139012224607,-6.01255760651371,-8.82983101668962,-7.91820968446726,-3.65012911561401,2.03916225484088,6.58906331124944,8.04886711607567,5.99239933005152,1.66085156208700,-2.72177958928039,-5.09617721401566,-4.58472806638474,-1.86295308531809,1.28743063961471,2.98936289112843,2.30076498147872,-0.283128407611000,-3.11905078702574,-4.33899997376100,-2.91220585885257,0.726669877887213,4.83080756187523,7.21355127746980,6.39555336848884,2.42904511269449,-3.04147477671223,-7.53429907714403,-8.93302005604852,-6.53313207335780,-1.40227141396893,4.13142128898521,7.60753886012294,7.61212054801035,4.41882709194733,-0.218029900995256,-3.99597871365575,-5.23370707074393,-3.67695863466014,-0.538867825632056,2.22458084469751,3.00591056246870,1.42048471043824,-1.49897672033347,-3.88735051386350,-4.09668529659391,-1.64695359093910,2.43749762003408,6.10083477562619,7.30661748606615,5.12557530312003,0.288984091810611,-5.09604630811490,-8.54410090641850,-8.40722403085783,-4.69601986379987,0.911598568644176,5.88190837555236,8.05034351935763,6.64599945213392,2.60777809979592,-1.95195859288767,-4.84656158556532,-4.90649030905994,-2.50728238589303,0.721030020423592,2.82983101668961,2.62668209837712,0.316707717496337,-2.62726509681823,-4.29296271705893,-3.41080439589926,-0.107687647632106,4.08079045230625,6.96442027639969,6.83788527754245,3.41418613428796,-1.94340661966383,-6.83070783468243,-8.96047125116161,-7.28958265529398,-2.54525201334493,3.11905078702573,7.16738039471698,7.90102353266785,5.24443848214596,0.712469633192526,-3.40719157248793,-5.22501143639206,-4.17075317622124,-1.20116591040700,1.79265706275079,3.04830837362913,1.89506935318139,-0.893829180221631,-3.54331844700782,-4.27411746200533,-2.32059296192025};
	COMPLEX origin_signal[N];
	//1. 입력 신호 생성 
	for(int i=0; i<N; i++)
	{
		origin_signal[i].real = in[i];
		origin_signal[i].imag = 0;
	}
	//결과를 받을 공간 생성 
	COMPLEX dft_done[N];
	COMPLEX recover_signal[N];
	
	DFT(origin_signal, true);
	
	for(int i=0; i<N; i++)
		printf("%d: (%4f, %4f)\n", i, origin_signal[i].real, origin_signal[i].imag);
	
	cout << endl << endl;
	
	DFT(origin_signal, false);
	
	for(int i=0; i<N; i++)
		printf("%d: (%4f, %4f)\n", i, origin_signal[i].real, origin_signal[i].imag);
	
	return 0;
}

inline unsigned bitreverse(const unsigned n, const unsigned k) 
{
    unsigned r, i;
    
    for (r = 0, i = 0; i < k; ++i)
	    r |= ((n >> i) & 1) << (k - i - 1);
        
    return r;
}

void DFT(COMPLEX *origin_signal, bool flag) //실수 행렬 입력받아 복소수 행렬 반환! 
{
	const unsigned k = __builtin_ctz(N);
    unsigned T, i, j;
    int l;
    
	/*재배열*/ 
    for (i = 0; i < N; i++) 
	{
        j = bitreverse(i, k);
        if (i < j)
            swap(origin_signal[i], origin_signal[j]);
    }
    
	/*푸리에 변환*/
	for(T = 2; T <= N; T *= 2) 
	{
	    COMPLEX W[T/2];
        for (i = 0; i < T/2; i++) 
	    {
	    	if(flag == true) l = -1;
	    	else l = 1;
	    	
            long double t = 2*PI*i/T*l;
            W[i].real = cos(t);
            W[i].imag = sin(t);
        }
        for (i = 0; i < N; i += T) 
        {
            for (j = 0; j < T/2; j++) 
            {
                COMPLEX tmp = mulc(origin_signal[i+j+T/2], W[j]);
                
			    origin_signal[i + j + T/2] = subc(origin_signal[i+j], tmp);
			    origin_signal[i+j] = addc(origin_signal[i+j], tmp);
            }
        }
    }
    
    if(!flag)
    {
    	for(i=0; i<N; i++)
    	{
    		origin_signal[i].real = origin_signal[i].real/N;
    		origin_signal[i].imag = origin_signal[i].imag/N;
		}
	}
}
```

그리고 FFT와 역 DFT를 수행한 결과는 다음과 같습니다.

```
0: (-0.000001, 0.000000)
1: (0.000000, -0.000009)
2: (0.000003, -0.000004)
3: (-0.000011, -0.000022)
4: (-0.000001, 0.000003)
5: (-0.000001, -0.000014)
6: (0.000008, -0.000010)
7: (-0.000029, -0.000066)
8: (-0.000001, 0.000000)
9: (0.000003, -0.000013)
10: (192.000000, 0.000111)
11: (-0.000012, -0.000058)
12: (0.000002, -0.000001)
13: (-0.000008, -0.000041)
14: (-0.000029, -0.000011)
15: (-90.804474, -373.109314)
16: (0.000000, -0.000001)
17: (0.000057, 0.000014)
18: (-0.000010, -0.000004)
19: (0.000004, 0.000064)
20: (0.000000, -0.000001)
21: (0.000005, 0.000018)
22: (-0.000020, -0.000024)
23: (0.000009, 0.000061)
24: (0.000001, -0.000000)
25: (-0.000001, 0.000005)
26: (-0.000025, -0.000007)
27: (-0.000000, 0.000019)
28: (0.000000, 0.000001)
29: (0.000004, 0.000009)
30: (-0.000005, -0.000005)
31: (-0.000010, 0.000082)
32: (0.000001, 0.000000)
33: (-0.000003, -0.000002)
34: (-0.000003, -0.000005)
35: (-0.000001, 0.000010)
36: (-0.000001, 0.000001)
37: (-0.000004, 0.000005)
38: (-0.000006, -0.000009)
39: (-0.000001, 0.000020)
40: (0.000001, -0.000002)
41: (-0.000001, 0.000006)
42: (-0.000012, -0.000009)
43: (-0.000003, 0.000011)
44: (0.000000, 0.000001)
45: (0.000002, -0.000002)
46: (-0.000005, -0.000007)
47: (-0.000018, 0.000044)
48: (-0.000002, -0.000001)
49: (0.000107, 0.000015)
50: (0.000001, -0.000002)
51: (-0.000005, 0.000006)
52: (-0.000001, 0.000002)
53: (-0.000001, 0.000001)
54: (0.000008, -0.000056)
55: (-0.000011, 0.000011)
56: (0.000001, 0.000000)
57: (-0.000000, 0.000002)
58: (-0.000004, -0.000017)
59: (-0.000005, 0.000006)
60: (0.000000, -0.000001)
61: (-0.000004, 0.000008)
62: (-0.000002, -0.000007)
63: (-0.000033, 0.000012)
64: (-0.000000, 0.000000)
65: (0.000001, -0.000002)
66: (-0.000000, -0.000006)
67: (-0.000005, 0.000000)
68: (0.000000, 0.000001)
69: (-0.000000, 0.000006)
70: (0.000002, -0.000005)
71: (-0.000006, 0.000007)
72: (0.000001, -0.000000)
73: (0.000002, 0.000003)
74: (0.000000, -0.000011)
75: (-0.000008, 0.000005)
76: (-0.000001, -0.000002)
77: (-0.000003, 0.000005)
78: (0.000008, -0.000009)
79: (-0.000019, 0.000046)
80: (-0.000002, 0.000001)
81: (0.000020, 0.000032)
82: (0.000002, -0.000003)
83: (-0.000002, 0.000005)
84: (0.000000, -0.000001)
85: (-0.000002, 0.000004)
86: (0.000020, -0.000019)
87: (-0.000015, 0.000008)
88: (0.000001, 0.000002)
89: (-0.000002, 0.000003)
90: (0.000004, -0.000004)
91: (-0.000009, 0.000001)
92: (-0.000001, -0.000001)
93: (0.000002, 0.000004)
94: (0.000011, -0.000008)
95: (-0.000025, -0.000011)
96: (0.000001, 0.000000)
97: (0.000006, 0.000013)
98: (0.000005, -0.000006)
99: (-0.000001, 0.000002)
100: (0.000000, -0.000001)
101: (-0.000003, 0.000007)
102: (0.000019, -0.000008)
103: (-0.000015, 0.000006)
104: (0.000001, 0.000000)
105: (-0.000000, 0.000011)
106: (0.000012, -0.000013)
107: (-0.000005, 0.000007)
108: (0.000000, 0.000001)
109: (-0.000011, 0.000018)
110: (0.000031, -0.000007)
111: (-0.000050, 0.000032)
112: (0.000000, 0.000001)
113: (-90.805222, 373.109131)
114: (0.000024, -0.000000)
115: (0.000005, -0.000042)
116: (0.000002, 0.000001)
117: (0.000009, -0.000020)
118: (192.000000, 0.000196)
119: (-0.000017, -0.000033)
120: (-0.000001, -0.000000)
121: (0.000004, -0.000017)
122: (0.000003, -0.000017)
123: (-0.000003, -0.000014)
124: (-0.000001, -0.000003)
125: (-0.000001, -0.000009)
126: (-0.000024, -0.000010)
127: (-0.000035, -0.000068)


0: (1.581173, 0.000000)
1: (5.509558, 0.000000)
2: (7.329399, 0.000000)
3: (5.821811, 0.000000)
4: (1.380858, 0.000000)
5: (-4.099195, -0.000000)
6: (-8.109293, -0.000000)
7: (-8.747553, 0.000001)
8: (-5.663125, 0.000000)
9: (-0.242731, 0.000000)
10: (5.057892, 0.000000)
11: (7.903047, -0.000000)
12: (7.190231, -0.000001)
13: (3.533611, 0.000000)
14: (-1.112017, 0.000000)
15: (-4.478238, 0.000000)
16: (-5.125575, -0.000000)
17: (-3.117364, 0.000000)
18: (0.107229, 0.000000)
19: (2.572993, -0.000000)
20: (2.863947, -0.000000)
21: (0.889661, 0.000000)
22: (-2.082140, -0.000001)
23: (-4.140201, 0.000000)
24: (-3.807702, 0.000000)
25: (-0.904358, 0.000000)
26: (3.276933, -0.000000)
27: (6.590022, -0.000000)
28: (7.142662, 0.000000)
29: (4.318389, 0.000000)
30: (-0.826139, 0.000000)
31: (-6.012558, 0.000001)
32: (-8.829830, -0.000000)
33: (-7.918210, 0.000000)
34: (-3.650128, -0.000000)
35: (2.039162, -0.000001)
36: (6.589064, -0.000000)
37: (8.048868, 0.000000)
38: (5.992399, -0.000000)
39: (1.660851, -0.000001)
40: (-2.721780, -0.000000)
41: (-5.096179, -0.000000)
42: (-4.584728, 0.000000)
43: (-1.862953, -0.000001)
44: (1.287430, 0.000001)
45: (2.989364, 0.000001)
46: (2.300765, 0.000000)
47: (-0.283128, 0.000000)
48: (-3.119051, 0.000000)
49: (-4.339000, -0.000000)
50: (-2.912206, 0.000001)
51: (0.726670, -0.000001)
52: (4.830808, -0.000000)
53: (7.213552, 0.000000)
54: (6.395553, 0.000000)
55: (2.429046, -0.000000)
56: (-3.041475, -0.000000)
57: (-7.534299, -0.000000)
58: (-8.933020, -0.000000)
59: (-6.533133, -0.000001)
60: (-1.402271, 0.000000)
61: (4.131422, 0.000000)
62: (7.607538, 0.000000)
63: (7.612121, -0.000000)
64: (4.418827, -0.000000)
65: (-0.218031, -0.000000)
66: (-3.995978, -0.000000)
67: (-5.233707, -0.000000)
68: (-3.676959, -0.000000)
69: (-0.538868, 0.000000)
70: (2.224579, 0.000000)
71: (3.005911, -0.000000)
72: (1.420485, 0.000000)
73: (-1.498977, -0.000000)
74: (-3.887350, 0.000000)
75: (-4.096686, -0.000000)
76: (-1.646954, 0.000000)
77: (2.437497, 0.000000)
78: (6.100835, 0.000000)
79: (7.306619, 0.000000)
80: (5.125575, -0.000000)
81: (0.288984, -0.000000)
82: (-5.096046, -0.000000)
83: (-8.544102, 0.000000)
84: (-8.407224, 0.000000)
85: (-4.696020, -0.000000)
86: (0.911598, 0.000000)
87: (5.881908, -0.000000)
88: (8.050343, 0.000000)
89: (6.646000, -0.000000)
90: (2.607778, 0.000000)
91: (-1.951960, 0.000001)
92: (-4.846561, 0.000000)
93: (-4.906491, -0.000000)
94: (-2.507282, 0.000001)
95: (0.721030, -0.000000)
96: (2.829831, 0.000000)
97: (2.626683, 0.000000)
98: (0.316708, 0.000000)
99: (-2.627266, 0.000001)
100: (-4.292963, 0.000000)
101: (-3.410806, -0.000000)
102: (-0.107687, 0.000000)
103: (4.080791, -0.000000)
104: (6.964420, 0.000000)
105: (6.837886, -0.000000)
106: (3.414186, -0.000001)
107: (-1.943407, 0.000001)
108: (-6.830707, -0.000001)
109: (-8.960472, -0.000001)
110: (-7.289582, -0.000000)
111: (-2.545252, -0.000000)
112: (3.119051, 0.000000)
113: (7.167380, 0.000000)
114: (7.901022, -0.000000)
115: (5.244439, 0.000001)
116: (0.712469, 0.000000)
117: (-3.407192, 0.000000)
118: (-5.225011, -0.000000)
119: (-4.170753, 0.000000)
120: (-1.201166, -0.000000)
121: (1.792657, 0.000000)
122: (3.048309, -0.000000)
123: (1.895070, 0.000001)
124: (-0.893829, -0.000001)
125: (-3.543319, -0.000001)
126: (-4.274116, -0.000001)
127: (-2.320594, -0.000000)
```

역FFT의 결과가 초기 입력 신호와 동일한 걸 확인할 수 있습니다.(FFT와 IFFT간의 쌍대성 성립)

이 결과를 MATLAB 코드를 이용해 그래프로 구현해봤습니다.

![](https://ifh.cc/g/gzWBel.png)

![](https://ifh.cc/g/qkIn8o.png)

![](https://ifh.cc/g/g05DFw.png)

결과는 다음과 같습니다.

첫 번째 그래프는 x(t) = 3cos(20πt) + 6sin(30πt - 3/(4π))를 그래프로 구현한 것이며, 두 번째와 세 번째 그래프는 DFT의 결과를 주파수에 따른 magnitude와 phase의 차원에서 그린 것입니다.

구현한 Matlab 코드는 다음과 같습니다.

```
t = [0:0.0078125:1];
for(a = 1:128)
    b = 3*cos(20*pi*t) + 6*sin(30*pi*t - 3/(4*pi));
end

f = 128*(0:(128/2))/128; 

result_real = {-0.000001
0.000000
0.000003
-0.000011
.
.
.
-0.000024
-0.000035
0
}

result_imag = {
    0.000000
-0.000009
-0.000004
-0.000022
.
.
.
-0.000010
-0.000068
0
}

result_real = result_real.';
result_imag = result_imag.';
result_real = cell2mat(result_real);
result_imag = cell2mat(result_imag);

figure();
plot(t, b);
xlabel('시간');
ylabel('진폭');

figure();
plot(t, result_real);
xlabel('주파수');
ylabel('크기');

figure();
plot(t, result_imag);
xlabel('주파수');
ylabel('위상');
```

그리고 IDFT로 다시 복원한 신호와 처음 신호를 비교한 그래프는 다음과 같습니다.

![](https://ifh.cc/g/mqTSBi.png)

# 결론

푸리에 변환과 DFT의 개념을 정리하고 DFT와 FFT 코드를 C++ 언어로 실제로 구현하여 그 결과를 시간복잡도 측면에서 비교하였습니다. FFT는 쿨리-튜키 알고리즘을 사용하였으며 결과는 MATLAB을 사용하여 그래프로 구현하였습니다.

DFT를 구현하였을 때는 Big O 표기법으로 표기하였을 때 시간복잡도가 O(n<sup>2</sup>)지만 데이터 샘플링 개수에 제약이 없었습니다. 그러나 쿨리-튜키 알고리즘을 사용한  FFT는 O(nlog<sub>2</sub>n)로 더 빠르지만 데이터 샘플링 개수가 무조건 2의 n승이어야 한다는 제약이 붙었습니다.

이렇게 구현한 결과의 행렬들은 주파수에 따른 magnitude와 phase를 보여주지만 정확한 주파수의 위치까지는 구현하지 못했습니다. 실제로 위에서 구현한 x(t)의 FFT 결과는 주파수 0을 중심으로 좌우로 그래프가 그려져있었어야 합니다.

따라서 FFT를 구현할 때 시간 도메인에서 정확한 주파수 도메인으로 매칭될 수 있도록 구현할 수 있는 방안을 좀 더 모색해야겠습니다.